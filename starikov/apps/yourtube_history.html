<div id="youtube-analyzer-widget">
    <style>
        /* Scoped CSS Variables and Base Widget Styles */
        #youtube-analyzer-widget {
            --bg-primary: #0a0a0a;
            --bg-secondary: #141414;
            --bg-tertiary: #1f1f1f;
            --text-primary: #ffffff;
            --text-secondary: #a8a8a8;
            --text-muted: #666666;
            --accent-red: #ff0000;
            --accent-red-hover: #cc0000;
            --accent-green: #10b981;
            --accent-blue: #3b82f6;
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);
            --radius-sm: 6px;
            --radius-md: 12px;
            --radius-lg: 16px;

            /* Former body styles, now applied to the widget container */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            position: relative; /* To contain the absolutely positioned loading overlay */
            /* overflow-x: hidden; /* Consider if the widget root itself should hide overflow */
        }

        #youtube-analyzer-widget * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Scoped Scrollbar Styling */
        #youtube-analyzer-widget ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        #youtube-analyzer-widget ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        #youtube-analyzer-widget ::-webkit-scrollbar-thumb {
            background: var(--text-muted);
            border-radius: 5px;
        }

        #youtube-analyzer-widget ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Container & Layout (Scoped) */
        #youtube-analyzer-widget .app-container {
            min-height: 100vh; /* This makes the widget try to be full viewport height.
                                  For fitting into a smaller space on a ghost site, you might adjust this
                                  (e.g., to '100%' if #youtube-analyzer-widget has a defined height, or 'auto').
                                  Keeping it allows the widget to dictate its primary app-like experience. */
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f0f0f 100%);
            position: relative;
            overflow: hidden; /* Retain for internal effects like ::before */
        }

        #youtube-analyzer-widget .app-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.03) 0%, transparent 70%);
            animation: pulse 20s ease-in-out infinite; /* Keyframe names are global */
            pointer-events: none;
        }

        /* Keyframes are defined globally, they don't need scoping in definition */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.3; }
        }

        #youtube-analyzer-widget .content-wrapper {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }

        /* Header (Scoped) */
        #youtube-analyzer-widget .header {
            text-align: center;
            margin-bottom: 3rem;
            animation: fadeInDown 0.8s ease-out; /* Keyframe name is global */
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #youtube-analyzer-widget .logo-wrapper {
            display: inline-flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        #youtube-analyzer-widget .youtube-logo {
            width: 60px;
            height: 60px;
            background: var(--accent-red);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 4px 20px rgba(255, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        #youtube-analyzer-widget .youtube-logo:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 6px 30px rgba(255, 0, 0, 0.5);
        }

        #youtube-analyzer-widget .youtube-logo::after {
            content: '‚ñ∂';
            color: white;
            font-size: 24px;
            margin-left: 2px;
        }

        #youtube-analyzer-widget h1 { /* Scoped h1 */
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(135deg, #ffffff 0%, #ff6b6b 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0; /* Already reset by *, but explicit here */
        }

        #youtube-analyzer-widget .subtitle {
            color: var(--text-secondary);
            font-size: 1.2rem;
            margin-top: 0.5rem;
            font-weight: 300;
        }

        /* Upload Section (Scoped) */
        #youtube-analyzer-widget .upload-card {
            background: var(--bg-secondary);
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-lg);
            padding: 4rem;
            text-align: center;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            animation: fadeIn 0.8s ease-out 0.2s both; /* Keyframe name is global */
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #youtube-analyzer-widget .upload-card::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.1) 0%, transparent 70%);
            transition: all 0.6s ease;
            transform: translate(-50%, -50%);
        }

        #youtube-analyzer-widget .upload-card:hover::before {
            width: 100%;
            height: 100%;
        }

        #youtube-analyzer-widget .upload-card:hover {
            border-color: var(--accent-red);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        #youtube-analyzer-widget .upload-card.dragover {
            border-color: var(--accent-red);
            background: rgba(255, 0, 0, 0.05);
            transform: scale(1.02);
        }

        #youtube-analyzer-widget .upload-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: bounce 2s ease-in-out infinite; /* Keyframe name is global */
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        #youtube-analyzer-widget .upload-card h3 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        #youtube-analyzer-widget .upload-card p {
            color: var(--text-secondary);
        }

        #youtube-analyzer-widget input[type="file"] {
            display: none;
        }

        /* Parameters Section (Scoped) */
        #youtube-analyzer-widget .parameters-card {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: 2rem;
            margin-bottom: 2rem;
            display: none;
            animation: slideIn 0.5s ease-out; /* Keyframe name is global */
            box-shadow: var(--shadow-md);
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        #youtube-analyzer-widget .parameters-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 2rem;
        }

        #youtube-analyzer-widget .parameters-header h3 {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #youtube-analyzer-widget .param-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        #youtube-analyzer-widget .param-group {
            background: var(--bg-tertiary);
            padding: 1.5rem;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        #youtube-analyzer-widget .param-group:hover {
            border-color: var(--accent-red);
            box-shadow: var(--shadow-sm);
        }

        #youtube-analyzer-widget .param-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
            font-weight: 500;
            font-size: 0.9rem;
        }

        #youtube-analyzer-widget .param-group input[type="number"],
        #youtube-analyzer-widget .param-group input[type="text"],
        #youtube-analyzer-widget .param-group input[type="date"],
        #youtube-analyzer-widget .param-group select {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.3s ease;
        }

        #youtube-analyzer-widget .param-group input:focus,
        #youtube-analyzer-widget .param-group select:focus {
            outline: none;
            border-color: var(--accent-red);
            box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.1);
        }

        #youtube-analyzer-widget .param-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 0.5rem;
            vertical-align: middle;
            accent-color: var(--accent-red);
            cursor: pointer;
        }

        #youtube-analyzer-widget .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        /* Buttons (Scoped) */
        #youtube-analyzer-widget .btn {
            background: var(--accent-red);
            color: white;
            border: none;
            padding: 0.875rem 2rem;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 0.5rem;
            position: relative;
            overflow: hidden;
        }

        #youtube-analyzer-widget .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        #youtube-analyzer-widget .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        #youtube-analyzer-widget .btn:hover {
            background: var(--accent-red-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        #youtube-analyzer-widget .btn:active {
            transform: translateY(0);
        }

        #youtube-analyzer-widget .btn:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
        }

        #youtube-analyzer-widget .btn-secondary {
            background: var(--accent-green);
        }

        #youtube-analyzer-widget .btn-secondary:hover {
            background: #059669;
        }

        #youtube-analyzer-widget .btn-outline {
            background: transparent;
            border: 2px solid var(--accent-red);
            color: var(--accent-red);
        }

        #youtube-analyzer-widget .btn-outline:hover {
            background: var(--accent-red);
            color: white;
        }

        #youtube-analyzer-widget .button-group {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        /* Stats Section (Scoped) */
        #youtube-analyzer-widget .stats-card {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: 2rem;
            margin-bottom: 2rem;
            display: none;
            animation: fadeIn 0.5s ease-out; /* Keyframe name is global */
            box-shadow: var(--shadow-md);
        }

        #youtube-analyzer-widget .stats-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        #youtube-analyzer-widget .stats-header h3 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        #youtube-analyzer-widget .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        #youtube-analyzer-widget .stat-item {
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            padding: 1.5rem;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        #youtube-analyzer-widget .stat-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--accent-red);
            transform: scaleY(0);
            transition: transform 0.3s ease;
        }

        #youtube-analyzer-widget .stat-item:hover::before {
            transform: scaleY(1);
        }

        #youtube-analyzer-widget .stat-item:hover {
            transform: translateX(4px);
            box-shadow: var(--shadow-sm);
        }

        #youtube-analyzer-widget .stat-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        #youtube-analyzer-widget .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-red);
        }

        #youtube-analyzer-widget .stat-subvalue {
            font-size: 0.875rem;
            color: var(--text-primary);
            margin-top: 0.25rem;
        }

        /* Results Section (Scoped) */
        #youtube-analyzer-widget .results-card {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: 2rem;
            display: none;
            animation: fadeIn 0.5s ease-out; /* Keyframe name is global */
            box-shadow: var(--shadow-md);
        }

        #youtube-analyzer-widget .results-header {
            margin-bottom: 2rem;
        }

        #youtube-analyzer-widget .results-header h3 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        #youtube-analyzer-widget .results-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        #youtube-analyzer-widget .search-wrapper {
            flex: 1;
            min-width: 300px;
            position: relative;
        }

        #youtube-analyzer-widget .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }

        #youtube-analyzer-widget .search-box {
            width: 100%;
            padding: 0.875rem 1rem 0.875rem 3rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 15px;
            transition: all 0.3s ease;
        }

        #youtube-analyzer-widget .search-box:focus {
            outline: none;
            border-color: var(--accent-red);
            box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.1);
        }

        /* Table (Scoped) */
        #youtube-analyzer-widget .table-container {
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            overflow: hidden;
            margin-top: 1.5rem;
            box-shadow: var(--shadow-sm);
        }

        #youtube-analyzer-widget .table-scroll {
            overflow-x: auto;
            max-height: 600px;
            overflow-y: auto;
        }

        #youtube-analyzer-widget table {
            width: 100%;
            border-collapse: collapse;
            min-width: 800px;
        }

        #youtube-analyzer-widget thead {
            position: sticky;
            top: 0;
            z-index: 10; /* Ensure this z-index is relative to #youtube-analyzer-widget stacking context */
        }

        #youtube-analyzer-widget th {
            background: rgba(255, 0, 0, 0.1);
            color: var(--text-primary);
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
            transition: all 0.3s ease;
            border-bottom: 2px solid var(--accent-red);
        }

        #youtube-analyzer-widget th:hover {
            background: rgba(255, 0, 0, 0.2);
        }

        #youtube-analyzer-widget th .sort-icon {
            margin-left: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        #youtube-analyzer-widget td {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        #youtube-analyzer-widget tbody tr {
            transition: all 0.3s ease;
        }

        #youtube-analyzer-widget tbody tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        #youtube-analyzer-widget .rank-cell {
            text-align: center;
            font-weight: 600;
            color: var(--text-secondary);
        }

        #youtube-analyzer-widget .video-info {
            min-width: 350px;
        }

        #youtube-analyzer-widget .video-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        #youtube-analyzer-widget .video-url {
            color: var(--accent-red);
            text-decoration: none;
            font-size: 0.875rem;
            transition: all 0.3s ease;
        }

        #youtube-analyzer-widget .video-url:hover {
            color: var(--accent-red-hover);
            text-decoration: underline;
        }

        #youtube-analyzer-widget .channel-name {
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        #youtube-analyzer-widget .play-count {
            font-weight: 700;
            color: var(--accent-green);
            text-align: center;
        }

        #youtube-analyzer-widget .date-cell {
            white-space: nowrap;
            color: var(--text-secondary);
        }

        /* Loading State (Scoped and Modified) */
        #youtube-analyzer-widget .loading-overlay {
            position: absolute; /* Changed from fixed to be contained by #youtube-analyzer-widget */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none; /* Initial state */
            align-items: center;
            justify-content: center;
            z-index: 1000; /* High z-index within the widget */
            backdrop-filter: blur(10px); /* May not work in all browsers without host enabling */
        }

        #youtube-analyzer-widget .loading-content {
            text-align: center;
            padding: 3rem;
        }

        #youtube-analyzer-widget .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid var(--accent-red);
            border-radius: 50%;
            animation: spin 1s linear infinite; /* Keyframe name is global */
            margin: 0 auto 2rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #youtube-analyzer-widget .progress-wrapper {
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }

        #youtube-analyzer-widget .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        #youtube-analyzer-widget .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-red) 0%, #ff6b6b 100%);
            transition: width 0.3s ease;
            width: 0%;
        }

        #youtube-analyzer-widget .progress-text {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }

        /* Alerts (Scoped) */
        #youtube-analyzer-widget .alert {
            padding: 1rem 1.5rem;
            border-radius: var(--radius-md);
            margin: 1rem 0;
            display: none;
            font-weight: 500;
            animation: slideDown 0.3s ease-out; /* Keyframe name is global */
            position: relative;
            padding-right: 3rem;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #youtube-analyzer-widget .alert-close {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: inherit;
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        #youtube-analyzer-widget .alert-close:hover {
            opacity: 1;
        }

        #youtube-analyzer-widget .alert-error {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        #youtube-analyzer-widget .alert-success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--accent-green);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        /* Empty State (Scoped) */
        #youtube-analyzer-widget .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }

        #youtube-analyzer-widget .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Responsive Design (Scoped) */
        @media (max-width: 768px) {
            #youtube-analyzer-widget .content-wrapper {
                padding: 1rem;
            }

            #youtube-analyzer-widget h1 {
                font-size: 2rem;
            }

            #youtube-analyzer-widget .upload-card {
                padding: 2rem 1rem;
            }

            #youtube-analyzer-widget .param-grid {
                grid-template-columns: 1fr;
            }

            #youtube-analyzer-widget .stats-grid {
                grid-template-columns: 1fr;
            }

            #youtube-analyzer-widget .results-controls {
                flex-direction: column;
            }

            #youtube-analyzer-widget .search-wrapper {
                min-width: 100%;
            }

            #youtube-analyzer-widget .table-scroll {
                max-height: 400px;
            }

            #youtube-analyzer-widget .video-info {
                min-width: 250px;
            }

            #youtube-analyzer-widget .channel-name {
                max-width: 150px;
            }
        }

        /* Animations for staggered entry (Scoped by application to specific classes within the widget) */
        #youtube-analyzer-widget .fade-in-up {
            animation: fadeInUp 0.6s ease-out both; /* Keyframe name is global */
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #youtube-analyzer-widget .stagger-1 { animation-delay: 0.1s; }
        #youtube-analyzer-widget .stagger-2 { animation-delay: 0.2s; }
        #youtube-analyzer-widget .stagger-3 { animation-delay: 0.3s; }
        #youtube-analyzer-widget .stagger-4 { animation-delay: 0.4s; }
    </style>

    <div class="app-container">
        <div class="content-wrapper">
            <header class="header">
                <div class="logo-wrapper">
                    <div class="youtube-logo"></div>
                    <h1>YourTube History</h1>
                </div>
                <p class="subtitle">Like and subscribe to find out what you've subscribed to!</p>
            </header>

            <div class="upload-card fade-in-up stagger-1" id="uploadSection">
                <div class="upload-icon">üìÇ</div>
                <h3>Drop your watch-history.html file here</h3>
                <p>or click to browse from your device</p>
                <input type="file" id="fileInput" accept=".html,.htm">
            </div>

            <div class="alert alert-error" id="errorAlert">
                <span id="errorMessage"></span>
                <button class="alert-close" onclick="closeAlert('error')">√ó</button>
            </div>
            <div class="alert alert-success" id="successAlert">
                <span id="successMessage"></span>
                <button class="alert-close" onclick="closeAlert('success')">√ó</button>
            </div>

            <div class="parameters-card fade-in-up stagger-2" id="parametersCard">
                <div class="parameters-header">
                    <h3>‚öôÔ∏è Analysis Parameters</h3>
                </div>
                <div class="param-grid">
                    <div class="param-group">
                        <label for="topN">Number of Top Videos</label>
                        <input type="number" id="topN" value="100" min="1" max="10000">
                    </div>
                    <div class="param-group">
                        <label for="minPlays">Minimum Play Count</label>
                        <input type="number" id="minPlays" value="2" min="1">
                    </div>
                    <div class="param-group">
                        <label for="dateFrom">From Date</label>
                        <input type="date" id="dateFrom">
                    </div>
                    <div class="param-group">
                        <label for="dateTo">To Date</label>
                        <input type="date" id="dateTo">
                    </div>
                    <div class="param-group">
                        <label for="channelFilter">Channel Filter</label>
                        <input type="text" id="channelFilter" placeholder="e.g., TechChannel">
                    </div>
                    <div class="param-group">
                        <label for="sortBy">Sort By</label>
                        <select id="sortBy">
                            <option value="plays">Play Count</option>
                            <option value="title">Video Title</option>
                            <option value="channel">Channel Name</option>
                            <option value="recent">Most Recent</option>
                            <option value="oldest">Oldest First</option>
                        </select>
                    </div>
                    <div class="param-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="excludeMusic" checked>
                            Exclude YouTube Music
                        </label>
                    </div>
                    <div class="param-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="showCharts" checked>
                            Show Visualizations
                        </label>
                    </div>
                </div>
                <div class="button-group">
                    <button class="btn" onclick="analyzer.processFile()">
                        <span>üöÄ Analyze History</span>
                    </button>
                    <button class="btn btn-secondary" onclick="analyzer.reset()">
                        <span>üîÑ Reset</span>
                    </button>
                </div>
            </div>

            <div class="stats-card fade-in-up stagger-3" id="statsCard">
                <div class="stats-header">
                    <h3>üìà Watch Statistics</h3>
                    <p class="subtitle">Your YouTube journey at a glance</p>
                </div>
                <div class="stats-grid" id="statsGrid"></div>
            </div>

            <div class="results-card fade-in-up stagger-4" id="resultsCard">
                <div class="results-header">
                    <h3>üé¨ Top Videos</h3>
                    <div class="results-controls">
                        <div class="search-wrapper">
                            <span class="search-icon">üîç</span>
                            <input type="text" class="search-box" id="searchBox" placeholder="Search videos, channels...">
                        </div>
                        <div class="button-group">
                            <button class="btn btn-outline" onclick="analyzer.exportCSV()">
                                <span>üìä Export CSV</span>
                            </button>
                            <button class="btn btn-outline" onclick="analyzer.exportJSON()">
                                <span>üìÑ Export JSON</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="table-container">
                    <div class="table-scroll">
                        <table id="resultsTable">
                            <thead>
                                <tr>
                                    <th onclick="analyzer.sortTable('rank')" style="width: 80px;">
                                        Rank <span class="sort-icon">‚Üï</span>
                                    </th>
                                    <th onclick="analyzer.sortTable('title')">
                                        Video Title <span class="sort-icon">‚Üï</span>
                                    </th>
                                    <th onclick="analyzer.sortTable('channel')">
                                        Channel <span class="sort-icon">‚Üï</span>
                                    </th>
                                    <th onclick="analyzer.sortTable('plays')" style="width: 100px;">
                                        Plays <span class="sort-icon">‚Üï</span>
                                    </th>
                                    <th onclick="analyzer.sortTable('date')" style="width: 160px;">
                                        First Watched <span class="sort-icon">‚Üï</span>
                                    </th>
                                </tr>
                            </thead>
                            <tbody id="resultsBody">
                                <tr>
                                    <td colspan="5" class="empty-state">
                                        <div class="empty-state-icon">üìÅ</div>
                                        <p>No data to display</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <h3>Processing Your Watch History</h3>
            <div class="progress-wrapper">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar"></div>
                </div>
                <p class="progress-text" id="progressText">Initializing...</p>
            </div>
        </div>
    </div>

    <script>
        // Modern YouTube Watch History Analyzer
        class YouTubeAnalyzer {
            constructor() {
                this.videos = new Map();
                this.watchEvents = [];
                this.filteredVideos = [];
                this.currentSort = { field: 'plays', ascending: false };
                this.file = null;
                this.processing = false;

                this.init();
            }

            init() {
                this.setupEventListeners();
                this.setDefaultDates();
            }

            setupEventListeners() {
                // File upload
                const uploadSection = document.getElementById('uploadSection');
                const fileInput = document.getElementById('fileInput');

                uploadSection.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));

                // Drag and drop
                uploadSection.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadSection.classList.add('dragover');
                });

                uploadSection.addEventListener('dragleave', () => {
                    uploadSection.classList.remove('dragover');
                });

                uploadSection.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadSection.classList.remove('dragover');
                    if (e.dataTransfer.files[0]) {
                        this.handleFile(e.dataTransfer.files[0]);
                    }
                });

                // Search functionality
                const searchBox = document.getElementById('searchBox');
                searchBox.addEventListener('input', (e) => this.handleSearch(e.target.value));

                // Parameter changes
                const params = ['topN', 'minPlays', 'dateFrom', 'dateTo', 'channelFilter', 'sortBy', 'excludeMusic'];
                params.forEach(param => {
                    const element = document.getElementById(param);
                    if (element) {
                        element.addEventListener('change', () => {
                            if (this.videos.size > 0) {
                                this.applyFiltersAndDisplay();
                            }
                        });
                    }
                });
            }

            setDefaultDates() {
                const today = new Date();
                const oneYearAgo = new Date(today.getFullYear() - 1, today.getMonth(), today.getDate());

                document.getElementById('dateFrom').value = oneYearAgo.toISOString().split('T')[0];
                document.getElementById('dateTo').value = today.toISOString().split('T')[0];
            }

            handleFileSelect(event) {
                const file = event.target.files[0];
                if (file) this.handleFile(file);
            }

            handleFile(file) {
                if (!file.name.match(/\.html?$/i)) {
                    this.showError('Please upload an HTML file (watch-history.html)');
                    return;
                }

                this.file = file;
                this.showSuccess(`File loaded: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);
                document.getElementById('parametersCard').style.display = 'block';
            }

            async processFile() {
                if (!this.file) {
                    this.showError('Please upload a file first');
                    return;
                }

                if (this.processing) {
                    this.showError('Already processing a file');
                    return;
                }

                this.processing = true;
                this.showLoading(true);
                this.resetData();

                try {
                    const content = await this.readFile(this.file);
                    await this.parseHistory(content);
                } catch (error) {
                    console.error('Processing error:', error);
                    this.showError(`Error processing file: ${error.message}`);
                } finally {
                    this.processing = false;
                    this.showLoading(false);
                }
            }

            readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            }

            async parseHistory(htmlContent) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');

                const entries = doc.querySelectorAll('.outer-cell .content-cell');
                const totalEntries = entries.length;
                const excludeMusic = document.getElementById('excludeMusic').checked;

                if (totalEntries === 0) {
                    throw new Error('No watch history entries found in file');
                }

                let processed = 0;
                const batchSize = 100;

                for (let i = 0; i < entries.length; i += batchSize) {
                    const batch = Array.from(entries).slice(i, i + batchSize);

                    await new Promise(resolve => {
                        setTimeout(() => {
                            batch.forEach(entry => this.parseEntry(entry, excludeMusic));
                            processed += batch.length;
                            this.updateProgress(processed, totalEntries);
                            resolve();
                        }, 0);
                    });
                }

                this.finalizeProcessing();
            }

            parseEntry(contentCell, excludeMusic) {
                const text = contentCell.textContent || '';

                // Check if it's a watch event
                if (!text.includes('Watched') && !text.includes('Gesehen') && !text.includes('Regard√©')) return;

                // Skip music if needed
                if (excludeMusic && (text.includes('YouTube Music') ||
                    contentCell.querySelector('a[href*="music.youtube.com"]'))) { // More specific check for music links
                    return;
                }

                const videoLink = contentCell.querySelector('a');
                if (!videoLink || !videoLink.href) return;

                const videoUrl = videoLink.href;
                 // Adjusted to allow for youtu.be links and ensure it's a video
                if (!videoUrl.match(/youtube\.com\/watch\?v=|youtu\.be\//) && !videoUrl.includes('youtu.be/')) return;


                const videoId = this.extractVideoId(videoUrl);
                const videoTitle = videoLink.textContent.trim();

                // Extract channel info
                const { channelName, channelUrl } = this.extractChannelInfo(contentCell, videoUrl);

                // Extract date
                const { dateString, timestamp } = this.extractDate(contentCell);

                // Create watch event
                const watchEvent = {
                    videoId,
                    url: videoUrl,
                    title: videoTitle,
                    channel: channelName,
                    channelUrl,
                    dateString,
                    timestamp
                };

                this.watchEvents.push(watchEvent);

                // Aggregate video data
                if (timestamp && videoId) {
                    if (!this.videos.has(videoId)) {
                        this.videos.set(videoId, {
                            id: videoId,
                            title: videoTitle,
                            url: videoUrl,
                            channel: channelName,
                            channelUrl,
                            plays: 0,
                            firstWatched: timestamp,
                            lastWatched: timestamp,
                            watchDates: []
                        });
                    }

                    const video = this.videos.get(videoId);
                    video.plays++;
                    video.watchDates.push(timestamp);

                    if (timestamp < video.firstWatched) {
                        video.firstWatched = timestamp;
                    }
                    if (timestamp > video.lastWatched) {
                        video.lastWatched = timestamp;
                    }
                }
            }

            extractVideoId(url) {
                const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
                return match ? match[1] : null;
            }

            extractChannelInfo(contentCell, videoUrl) {
                const links = Array.from(contentCell.querySelectorAll('a'));
                let channelName = 'Unknown Channel';
                let channelUrl = '';

                const channelLink = links.find(link =>
                    link.href !== videoUrl &&
                    (link.href.includes('/@') ||
                     link.href.includes('/channel/') ||
                     link.href.includes('/c/') ||
                     link.href.includes('/user/'))
                );

                if (channelLink) {
                    channelName = channelLink.textContent.trim();
                    channelUrl = channelLink.href;
                }

                return { channelName, channelUrl };
            }

            extractDate(contentCell) {
                const datePatterns = [
                    // English format: Nov 15, 2023, 3:45:32 PM EST
                    /([A-Za-z]{3,9}\s\d{1,2},\s\d{4},\s\d{1,2}:\d{2}:\d{2}\s[AP]M(?:\s[A-Z]{2,4})?)/i,
                    // European format: 15 Nov 2023 15:45:32
                    /(\d{1,2}\s[A-Za-z]{3,9}\s\d{4}\s\d{1,2}:\d{2}:\d{2})/i,
                     // German format: 15. Nov. 2023, 15:45:32 MEZ
                    /(\d{1,2}\.\s[A-Za-z]{3,9}\.\s\d{4},\s\d{1,2}:\d{2}:\d{2}(?:\s[A-Z]{2,4})?)/i,
                    // ISO format
                    /(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z?)/i,
                    // Additional formats like DD/MM/YYYY HH:MM:SS AM/PM
                    /(\d{1,2}\/\d{1,2}\/\d{4}\s\d{1,2}:\d{2}:\d{2}\s[AP]M)/i
                ];

                const html = contentCell.innerHTML;
                const textParts = html.split(/<br\s*\/?>/i); // Split by <br> tags

                for (let i = textParts.length - 1; i >= 0; i--) { // Check last parts first, often where date is
                    const text = new DOMParser().parseFromString(textParts[i], 'text/html').body.textContent.trim();

                    for (const pattern of datePatterns) {
                        const match = text.match(pattern);
                        if (match) {
                            const dateString = match[1];
                            const timestamp = this.parseDate(dateString);

                            if (timestamp && !isNaN(timestamp.getTime())) {
                                return { dateString, timestamp };
                            }
                        }
                    }
                }

                return { dateString: 'Unknown Date', timestamp: null };
            }

            parseDate(dateString) {
                // Remove timezone abbreviations for better parsing, but handle cases like "MEZ" or "MESZ"
                let cleanedDate = dateString.replace(/\s(?:[A-Z]{3,4}|MEZ|MESZ)$/i, '');
                // German "Nov." -> "Nov"
                cleanedDate = cleanedDate.replace(/([A-Za-z]{3,9})\./i, '$1');


                try {
                    const date = new Date(cleanedDate);
                    if (!isNaN(date.getTime())) {
                        return date;
                    }
                } catch (e) {
                    // Try alternative parsing methods if direct Date construction fails
                }

                // Manual parsing for formats like "Month Day, Year, H:MM:SS AM/PM"
                const manualMatch = cleanedDate.match(/([A-Za-z]+)\s(\d+),\s(\d{4}),\s(\d+):(\d{2}):(\d{2})\s([AP]M)/i);
                if (manualMatch) {
                    const [_, month, day, year, hour, minute, second, ampm] = manualMatch;
                    const monthIndex = new Date(Date.parse(month + " 1, 2000")).getMonth(); // Robust month parsing
                    let hours = parseInt(hour);
                    if (ampm.toUpperCase() === 'PM' && hours !== 12) hours += 12;
                    if (ampm.toUpperCase() === 'AM' && hours === 12) hours = 0; // Midnight case

                    return new Date(parseInt(year), monthIndex, parseInt(day), hours, parseInt(minute), parseInt(second));
                }
                 // Manual parsing for "DD Month YYYY HH:MM:SS" (often European)
                const euroMatch = cleanedDate.match(/(\d{1,2})\s([A-Za-z]{3,9})\s(\d{4})\s(\d{1,2}):(\d{2}):(\d{2})/i);
                if (euroMatch) {
                    const [_, day, month, year, hour, minute, second] = euroMatch;
                    const monthIndex = new Date(Date.parse(month + " 1, 2000")).getMonth();
                    return new Date(parseInt(year), monthIndex, parseInt(day), parseInt(hour), parseInt(minute), parseInt(second));
                }


                return null; // If all parsing fails
            }


            updateProgress(processed, total) {
                const progress = Math.round((processed / total) * 100);
                document.getElementById('progressBar').style.width = `${progress}%`;
                document.getElementById('progressText').textContent = `Processing: ${processed.toLocaleString()} of ${total.toLocaleString()} entries (${progress}%)`;
            }

            finalizeProcessing() {
                const validVideos = this.videos.size;
                const totalEvents = this.watchEvents.length;

                if (validVideos === 0) {
                    this.showError('No valid watch events could be processed. Ensure the HTML file is a valid YouTube watch history file.');
                    return;
                }

                this.showSuccess(`Successfully processed ${validVideos.toLocaleString()} unique videos from ${totalEvents.toLocaleString()} watch events`);
                this.applyFiltersAndDisplay();
            }

            applyFiltersAndDisplay() {
                // Get filter values
                const minPlays = parseInt(document.getElementById('minPlays').value) || 1;
                const dateFromInput = document.getElementById('dateFrom').value;
                const dateToInput = document.getElementById('dateTo').value;

                // Ensure dates are parsed correctly as start/end of day for inclusive filtering
                const dateFrom = dateFromInput ? new Date(dateFromInput + "T00:00:00") : null;
                const dateTo = dateToInput ? new Date(dateToInput + "T23:59:59") : null;

                const channelFilter = document.getElementById('channelFilter').value.toLowerCase();
                const topN = parseInt(document.getElementById('topN').value) || 100;

                // Apply filters
                this.filteredVideos = Array.from(this.videos.values()).filter(video => {
                    if (video.plays < minPlays) return false;
                    // Date filtering: ensure video's firstWatched is within the range
                    if (dateFrom && video.firstWatched < dateFrom) return false;
                    if (dateTo && video.firstWatched > dateTo) return false;
                    if (channelFilter && !video.channel.toLowerCase().includes(channelFilter)) return false;
                    return true;
                });

                // Sort videos
                this.sortVideos(); // This uses currentSort state or sortBy dropdown

                // Display results
                this.displayStats();
                this.displayTable(this.filteredVideos.slice(0, topN));
            }


            sortVideos() {
                const sortBy = document.getElementById('sortBy').value;
                // For table header click sorting, currentSort is updated by sortTable method
                // For direct dropdown change, use sortBy directly
                const fieldToSortBy = this.currentSort.fieldForTable || sortBy; // Prefer table sort if active
                const ascending = (fieldToSortBy === this.currentSort.field) ? this.currentSort.ascending : (fieldToSortBy === 'title' || fieldToSortBy === 'channel' || fieldToSortBy === 'oldest');


                this.filteredVideos.sort((a, b) => {
                    let comparison = 0;
                    switch (fieldToSortBy) {
                        case 'plays':
                        case 'rank': // Rank is based on plays
                            comparison = a.plays - b.plays;
                            break;
                        case 'title':
                            comparison = a.title.localeCompare(b.title);
                            break;
                        case 'channel':
                            comparison = a.channel.localeCompare(b.channel);
                            break;
                        case 'recent': // Sort by lastWatched descending
                        case 'date': // Default for 'date' click is recent
                            comparison = a.lastWatched - b.lastWatched;
                            break;
                        case 'oldest': // Sort by firstWatched ascending
                            comparison = a.firstWatched - b.firstWatched;
                            break;
                        default:
                            comparison = a.plays - b.plays; // Default to plays
                    }
                    // If sortBy from dropdown is 'plays', 'recent', it's descending.
                    // If it's 'title', 'channel', 'oldest', it's ascending.
                    // This needs to align with currentSort.ascending for table clicks.

                    let sortOrderMultiplier = 1; // Ascending
                    if (sortBy === 'plays' || sortBy === 'recent') {
                        sortOrderMultiplier = -1; // Descending
                    }

                    // If sorting via table header, use this.currentSort.ascending
                    if (this.currentSort.fieldForTable) {
                         return this.currentSort.ascending ? comparison : -comparison;
                    } else {
                        // Default behavior for dropdown
                        if (sortBy === 'plays' || sortBy === 'recent') {
                             return -comparison; // Descending
                        }
                        return comparison; // Ascending for title, channel, oldest
                    }
                });
            }


            displayStats() {
                const statsGrid = document.getElementById('statsGrid');
                const stats = this.calculateStats();

                statsGrid.innerHTML = stats.map(stat => `
                    <div class="stat-item">
                        <div class="stat-label">${stat.label}</div>
                        <div class="stat-value">${stat.value}</div>
                        ${stat.subvalue ? `<div class="stat-subvalue">${stat.subvalue}</div>` : ''}
                    </div>
                `).join('');

                document.getElementById('statsCard').style.display = 'block';
            }

            calculateStats() {
                const allVideos = Array.from(this.videos.values());
                const validTimestamps = this.watchEvents.filter(e => e.timestamp && !isNaN(e.timestamp.getTime())).map(e => e.timestamp);

                if (validTimestamps.length === 0) {
                    return [{ label: 'No Data', value: 'No valid timestamps found' }];
                }

                const stats = [];

                // Date range
                const minDate = new Date(Math.min(...validTimestamps.map(d => d.getTime())));
                const maxDate = new Date(Math.max(...validTimestamps.map(d => d.getTime())));
                stats.push({
                    label: 'Data Period',
                    value: `${minDate.toLocaleDateString()} - ${maxDate.toLocaleDateString()}`
                });

                // Total statistics
                stats.push({
                    label: 'Total Watch Events',
                    value: this.watchEvents.length.toLocaleString()
                });

                stats.push({
                    label: 'Unique Videos',
                    value: allVideos.length.toLocaleString()
                });

                // Unique channels
                const uniqueChannels = new Set(allVideos.map(v => v.channel).filter(c => c && c !== 'Unknown Channel'));
                stats.push({
                    label: 'Unique Channels',
                    value: uniqueChannels.size.toLocaleString()
                });

                // Estimated hours (assuming 10 min average)
                const estimatedHours = Math.round(this.watchEvents.length * 10 / 60);
                stats.push({
                    label: 'Estimated Hours',
                    value: estimatedHours.toLocaleString(),
                    subvalue: 'Based on 10 min average'
                });

                // Average per day
                const daysDiff = Math.ceil((maxDate.getTime() - minDate.getTime()) / (1000 * 60 * 60 * 24)) || 1;
                const avgPerDay = (this.watchEvents.length / daysDiff).toFixed(1);
                stats.push({
                    label: 'Daily Average',
                    value: avgPerDay,
                    subvalue: 'Videos per day'
                });

                // Favorite channel
                const channelPlays = {};
                allVideos.forEach(video => {
                    if (video.channel && video.channel !== 'Unknown Channel') {
                        channelPlays[video.channel] = (channelPlays[video.channel] || 0) + video.plays;
                    }
                });

                const topChannel = Object.entries(channelPlays)
                    .sort(([,a], [,b]) => b - a)[0];

                if (topChannel) {
                    stats.push({
                        label: 'Favorite Channel',
                        value: topChannel[0],
                        subvalue: `${topChannel[1].toLocaleString()} plays`
                    });
                }

                // Most rewatched
                const mostRewatched = allVideos
                    .filter(v => v.plays > 1)
                    .sort((a, b) => b.plays - a.plays)[0];

                if (mostRewatched) {
                    stats.push({
                        label: 'Most Rewatched',
                        value: mostRewatched.title.substring(0, 30) + (mostRewatched.title.length > 30 ? '...' : ''),
                        subvalue: `${mostRewatched.plays.toLocaleString()} plays`
                    });
                }

                // Peak hour
                const hourCounts = new Array(24).fill(0);
                validTimestamps.forEach(ts => {
                    hourCounts[ts.getHours()]++;
                });
                const peakHour = hourCounts.indexOf(Math.max(...hourCounts));
                stats.push({
                    label: 'Peak Viewing Hour',
                    value: `${peakHour}:00 - ${(peakHour + 1) % 24}:00`,
                    subvalue: `${hourCounts[peakHour].toLocaleString()} watches`
                });

                return stats;
            }

            displayTable(videos) {
                const tbody = document.getElementById('resultsBody');

                if (videos.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="5" class="empty-state">
                                <div class="empty-state-icon">üîç</div>
                                <p>No videos match your filters</p>
                            </td>
                        </tr>
                    `;
                } else {
                    tbody.innerHTML = videos.map((video, index) => `
                        <tr>
                            <td class="rank-cell">${index + 1}</td>
                            <td class="video-info">
                                <div class="video-title" title="${this.escapeHtml(video.title)}">${this.escapeHtml(video.title)}</div>
                                <a href="${video.url}" target="_blank" class="video-url">Watch on YouTube ‚Üí</a>
                            </td>
                            <td class="channel-name" title="${this.escapeHtml(video.channel)}">${this.escapeHtml(video.channel)}</td>
                            <td class="play-count">${video.plays}</td>
                            <td class="date-cell">${video.firstWatched ? video.firstWatched.toLocaleDateString() : 'N/A'}</td>
                        </tr>
                    `).join('');
                }

                document.getElementById('resultsCard').style.display = 'block';
            }

            handleSearch(searchTerm) {
                const term = searchTerm.toLowerCase();
                const rows = document.querySelectorAll('#resultsBody tr');

                rows.forEach(row => {
                    // Make sure row has content, not the empty state td
                    if (row.cells.length > 1) {
                        const text = row.textContent.toLowerCase();
                        row.style.display = text.includes(term) ? '' : 'none';
                    }
                });
            }

            sortTable(field) {
                if (this.currentSort.field === field) {
                    this.currentSort.ascending = !this.currentSort.ascending;
                } else {
                    this.currentSort.field = field;
                    // Default sort order for new column clicks
                    this.currentSort.ascending = (field === 'title' || field === 'channel' || field === 'date'); // Ascending for text/date
                }
                this.currentSort.fieldForTable = field; // Indicate sort was triggered by table header

                // Map table header field to sortBy dropdown values if necessary
                const sortByMap = {
                    'rank': 'plays', // Rank is essentially sorted by plays
                    'date': this.currentSort.ascending ? 'oldest' : 'recent' // Map date click to oldest/recent
                };

                // Update the sortBy dropdown to reflect the current sort state, but don't trigger its change event
                const sortByDropdown = document.getElementById('sortBy');
                const valueToSet = sortByMap[field] || field;
                if (sortByDropdown.value !== valueToSet) {
                   // Temporarily disable change listener if needed, or just set value
                   // For simplicity, we'll let applyFiltersAndDisplay re-evaluate sort
                }

                this.applyFiltersAndDisplay();

                 // Update sort icons
                document.querySelectorAll('#resultsTable th .sort-icon').forEach(icon => {
                    icon.textContent = '‚Üï'; // Reset all icons
                });
                const activeTh = Array.from(document.querySelectorAll('#resultsTable th')).find(th => th.getAttribute('onclick').includes(`'${field}'`));
                if (activeTh) {
                    activeTh.querySelector('.sort-icon').textContent = this.currentSort.ascending ? 'üîº' : 'üîΩ';
                }

            }


            exportCSV() {
                const videos = this.filteredVideos.slice(0, parseInt(document.getElementById('topN').value) || this.filteredVideos.length);

                const csv = [
                    ['Rank', 'Title', 'Channel', 'Plays', 'URL', 'First Watched', 'Last Watched'],
                    ...videos.map((video, index) => [
                        index + 1,
                        `"${video.title.replace(/"/g, '""')}"`,
                        `"${(video.channel || '').replace(/"/g, '""')}"`,
                        video.plays,
                        video.url,
                        video.firstWatched ? video.firstWatched.toLocaleDateString() : 'N/A',
                        video.lastWatched ? video.lastWatched.toLocaleDateString() : 'N/A'
                    ])
                ].map(row => row.join(',')).join('\n');

                this.downloadFile(csv, `youtube-history-${new Date().toISOString().split('T')[0]}.csv`, 'text/csv;charset=utf-8;');
            }

            exportJSON() {
                const videos = this.filteredVideos.slice(0, parseInt(document.getElementById('topN').value) || this.filteredVideos.length);

                const data = {
                    exportDate: new Date().toISOString(),
                    totalVideosInHistory: this.videos.size,
                    totalWatchEvents: this.watchEvents.length,
                    filtersApplied: {
                        topN: document.getElementById('topN').value,
                        minPlays: document.getElementById('minPlays').value,
                        dateFrom: document.getElementById('dateFrom').value,
                        dateTo: document.getElementById('dateTo').value,
                        channelFilter: document.getElementById('channelFilter').value,
                        excludeMusic: document.getElementById('excludeMusic').checked,
                        sortBy: document.getElementById('sortBy').value
                    },
                    videosDisplayed: videos.map((video, index) => ({
                        rank: index + 1,
                        id: video.id,
                        title: video.title,
                        channel: video.channel,
                        plays: video.plays,
                        url: video.url,
                        firstWatched: video.firstWatched ? video.firstWatched.toISOString() : null,
                        lastWatched: video.lastWatched ? video.lastWatched.toISOString() : null,
                        allWatchDates: video.watchDates.map(d => d ? d.toISOString() : null)
                    }))
                };

                const json = JSON.stringify(data, null, 2);
                this.downloadFile(json, `youtube-history-${new Date().toISOString().split('T')[0]}.json`, 'application/json;charset=utf-8;');
            }

            downloadFile(content, filename, type) {
                const blob = new Blob([content], { type });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            escapeHtml(text) {
                if (text === null || typeof text === 'undefined') return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            showLoading(show) {
                document.getElementById('loadingOverlay').style.display = show ? 'flex' : 'none';
                if (show) {
                    document.getElementById('progressBar').style.width = '0%';
                    document.getElementById('progressText').textContent = 'Initializing...';
                }
            }

            showError(message) {
                document.getElementById('errorMessage').textContent = message;
                const errorAlert = document.getElementById('errorAlert');
                errorAlert.style.display = 'block';
                // Auto-hide after 5 seconds
                setTimeout(() => { if(errorAlert.style.display === 'block') closeAlert('error'); }, 5000);
            }

            showSuccess(message) {
                document.getElementById('successMessage').textContent = message;
                const successAlert = document.getElementById('successAlert')
                successAlert.style.display = 'block';
                 // Auto-hide after 5 seconds
                setTimeout(() => { if(successAlert.style.display === 'block') closeAlert('success'); }, 5000);
            }

            reset() {
                this.resetData();
                document.getElementById('fileInput').value = ''; // Clear file input
                document.getElementById('parametersCard').style.display = 'none';
                document.getElementById('statsCard').style.display = 'none';
                document.getElementById('resultsCard').style.display = 'none';

                // Reset parameters to defaults
                document.getElementById('topN').value = '100';
                document.getElementById('minPlays').value = '2';
                document.getElementById('excludeMusic').checked = true;
                document.getElementById('channelFilter').value = '';
                document.getElementById('sortBy').value = 'plays';
                this.setDefaultDates(); // Reset date inputs

                this.currentSort = { field: 'plays', ascending: false, fieldForTable: null }; // Reset sort state
                this.showSuccess('Analyzer reset. Upload a new file to start.');
            }

            resetData() {
                this.videos.clear();
                this.watchEvents = [];
                this.filteredVideos = [];
                this.file = null; // Clear stored file
            }
        }

        // Global functions (like closeAlert) need to be accessible.
        // If the script is inside #youtube-analyzer-widget, they are not truly global
        // to the external page, but accessible to inline onclick handlers within the widget.
        function closeAlert(type) {
            const alertElement = document.getElementById(`${type}Alert`);
            if (alertElement) {
                alertElement.style.display = 'none';
            }
        }

        // Initialize analyzer - ensure this runs after the DOM is ready or
        // that elements it interacts with exist. Since script is at the end, this is fine.
        const analyzer = new YouTubeAnalyzer();
    </script>
</div>
